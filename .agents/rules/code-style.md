# Code Style & Conventions

## Tooling

Biome handles both linting and formatting. No ESLint, Prettier, or separate formatters.

## Formatting Rules

- **Indent**: 2 spaces
- **Quotes**: Single quotes (JS/TS), double quotes (JSX)
- **Semicolons**: Always
- **Line width**: 160 characters
- **Trailing commas**: ES5 (objects, arrays, function parameters)
- **Arrow parentheses**: Always `(x) => x`
- **End of line**: LF
- **Final newline**: Always

## Auto-formatting

- **On save**: Configure editor to use Biome
- **Pre-commit**: lint-staged runs Biome on staged files
- **Manual**: `pnpm lint:fix`

## TypeScript Conventions

- Strict mode enabled
- Use `import type { ... }` for type-only imports
- Never use `any` â€” use `unknown` and narrow with type guards
- Prefer Prisma generated types over manual type definitions where possible
- Use explicit return types for exported functions
- Use `satisfies` operator for type-checked object literals
- For Zod schemas, declare the schema and type together in one block, so they can both be imported in one go, depending on the context of work (e.g. either as a type or a value):

```ts
// Good: Schema and type together
const CreatePerson = z.object({ name: z.string() });
type CreatePerson = z.infer<typeof CreatePerson>;

// Bad: Separate declarations
const createPersonSchema = z.object({ name: z.string() });
type CreatePerson = z.infer<typeof createPersonSchema>;
```

## Naming Conventions

| Element | Convention | Example |
|---------|-----------|---------|
| Variables, functions | camelCase | `birthOrder`, `computeKinship` |
| Components | PascalCase | `FamilyTree`, `PersonCard` |
| Types, interfaces, enums | PascalCase | `Person`, `RelationshipType` |
| Constants | UPPER_SNAKE_CASE | `MAX_GENERATION_DEPTH` |
| Files (general) | kebab-case | `kinship-helpers.ts` |
| Files (components) | PascalCase | `FamilyTree.tsx` |
| Files (routes) | kebab-case or $param | `$id.tsx`, `index.tsx` |
| Database columns | snake_case | `full_name`, `birth_year` |
| Prisma fields | camelCase | `fullName`, `birthYear` |

## Component Structure

Follow this order within each component file:

```tsx
// 1. Imports
import { useState } from 'react';
import { useSomething } from '@/lib/something';
import type { Person } from '@/types';

// 2. Types/interfaces (if component-specific)
interface Props {
  person: Person;
  onSelect: (id: string) => void;
}

// 3. Component
export function PersonCard({ person, onSelect }: Props) {
  // a. Hooks
  const [isOpen, setIsOpen] = useState(false);

  // b. Derived state
  const displayName = person.fullName;

  // c. Event handlers
  const handleClick = () => onSelect(person.id);

  // d. Effects (if needed)

  // e. Render
  return <div onClick={handleClick}>{displayName}</div>;
}
```

## Import Order

Biome auto-organizes imports:

1. React / React DOM
2. External packages (`@tanstack/*`, `framer-motion`, etc.)
3. Internal aliases (`@/components/*`, `@/lib/*`, `@/utils/*`)
4. Type imports (`import type { ... }`)
5. Style imports

## Comments

- Explain **why**, not **how**
- No JSDoc for self-explanatory functions
- Use `// TODO:` for known incomplete work
- No commented-out code in commits

## File Size

- Aim for < 300 lines per file
- Extract large components into smaller pieces
- Extract shared logic into utility functions or hooks

## Other Conventions

- Prefer early returns over deeply nested conditionals
- Destructure props in function parameters
- Use `const` by default, `let` only when reassignment is needed
- No `var`
- Prefer template literals over string concatenation

## Ignored Files

Biome skips these (configured in `biome.json`):
- `src/routeTree.gen.ts` (auto-generated by TanStack Router)
- `node_modules/`
- `dist/`
- `coverage/`
- `generated/` (Prisma client)
